<?php


namespace app\lib\exception;


use think\exception\Handle;
use think\Log;
use think\Request;

class ExceptionHandler extends Handle
{
    private $success;
    private $code;
    private $msg;
    private $errorCode;
    //需要返回客户端当前URL的路径


    //所有的错误都会经过这里，一旦创建了这里的代码就应当在config配置文件中对异常处理的默认类重定位
    public function render(\Exception $e)//Exception $e)调整为基类的Exception
    {
        if ($e instanceof BaseException) {
            //如果是自定义异常
            $this->success = $e->success;
            $this->code = $e->code;
            $this->msg = $e->msg;
            $this->errorCode = $e->errorCode;
        } else {
            //$switch = ture;
            if (config('app_debug')) {
                //return default error page：给服务端人员发送数据
                return parent::render($e);
            } else {//当开关关闭时则给客户端发送json数据
                $this->code = 500;
                $this->success = false;
                $this->msg = '服务器内部错误，不想告诉你';
                $this->errorCode = 999;//最好加入到API文档中去，起码要自己知道这是什么意思
                $this->recordErrorLog($e);
            }
        }

        $request = Request::instance();

        //这才是最终决定要返回客户端的内容！！！
        $result = [
            'success' => $this->success,
            'msg' => $this->msg,
            'error_code' => $this->errorCode,
            //需要返回客户端当前URL的路径
            'request_url' => $request->url()
        ];
        return json($result, $this->code);

        //return json("您所查找的趣袋信息不存在");//验证全局的异常，可以输出结果查看到
        //return parent::render($e); // TODO: Change the autogenerated stub
    }

    private function recordErrorLog(\Exception $e)//\Exception $e)
    {
        Log::init([
            'type' => 'File',
            'path' => LOG_PATH,
            'level' => ['error']//只有高于这个Error级别的才会被记录下去
        ]);
        Log::record($e->getMessage(), 'error');
    }
}